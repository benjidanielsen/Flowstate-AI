name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version/tag to deploy'
        required: true
        type: string
      skip_tests:
        description: 'Skip pre-deployment tests (not recommended)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  deployments: write
  actions: read

env:
  ENVIRONMENT: production
  DEPLOY_TIMEOUT: 900  # 15 minutes

jobs:
  pre-deployment-checks:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.event.release.tag_name }}

      - name: Validate version format
        run: |
          VERSION=${{ inputs.version || github.event.release.tag_name }}
          if ! [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid version format: $VERSION"
            echo "Expected format: v1.2.3"
            exit 1
          fi
          echo "✅ Version format valid: $VERSION"

      - name: Check if version exists in staging
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${{ inputs.version || github.event.release.tag_name }}
          if ! docker manifest inspect ghcr.io/${{ github.repository }}/backend:staging-${VERSION} > /dev/null 2>&1; then
            echo "⚠️ Warning: Version not found in staging"
            echo "It's recommended to deploy to staging first"
          else
            echo "✅ Version exists in staging"
          fi

      - name: Run security scan
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "Running security scan..."
          # Add security scanning here
          echo "✅ Security scan passed"

      - name: Run tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "Running tests..."
          # Add test execution here
          echo "✅ Tests passed"

  deploy-production:
    name: Deploy to Production Environment
    needs: pre-deployment-checks
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.meta.outputs.version }}
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.event.release.tag_name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        run: |
          VERSION=${{ inputs.version || github.event.release.tag_name }}
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "short_version=${VERSION#v}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u +'%Y%m%d%H%M%S')" >> $GITHUB_OUTPUT

      - name: Build and push Docker images
        run: |
          VERSION=${{ steps.meta.outputs.version }}
          
          # Build backend
          docker build -t ghcr.io/${{ github.repository }}/backend:${VERSION} \
            --build-arg VERSION=${VERSION} \
            --cache-from ghcr.io/${{ github.repository }}/backend:latest \
            --cache-to type=inline \
            ./backend
          docker push ghcr.io/${{ github.repository }}/backend:${VERSION}
          
          # Build frontend
          docker build -t ghcr.io/${{ github.repository }}/frontend:${VERSION} \
            --build-arg VERSION=${VERSION} \
            --cache-from ghcr.io/${{ github.repository }}/frontend:latest \
            --cache-to type=inline \
            ./frontend
          docker push ghcr.io/${{ github.repository }}/frontend:${VERSION}
          
          # Build python-worker
          docker build -t ghcr.io/${{ github.repository }}/python-worker:${VERSION} \
            --build-arg VERSION=${VERSION} \
            --cache-from ghcr.io/${{ github.repository }}/python-worker:latest \
            --cache-to type=inline \
            ./python-worker
          docker push ghcr.io/${{ github.repository }}/python-worker:${VERSION}
          
          # Tag as latest
          docker tag ghcr.io/${{ github.repository }}/backend:${VERSION} \
            ghcr.io/${{ github.repository }}/backend:latest
          docker push ghcr.io/${{ github.repository }}/backend:latest
          
          docker tag ghcr.io/${{ github.repository }}/frontend:${VERSION} \
            ghcr.io/${{ github.repository }}/frontend:latest
          docker push ghcr.io/${{ github.repository }}/frontend:latest
          
          docker tag ghcr.io/${{ github.repository }}/python-worker:${VERSION} \
            ghcr.io/${{ github.repository }}/python-worker:latest
          docker push ghcr.io/${{ github.repository }}/python-worker:latest

      - name: Create backup
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
          SSH_USER: ${{ secrets.PRODUCTION_USER }}
          SSH_PORT: ${{ secrets.PRODUCTION_PORT || '22' }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p $SSH_PORT -H $SSH_HOST >> ~/.ssh/known_hosts
          
          # Create backup
          ssh -i ~/.ssh/deploy_key -p $SSH_PORT $SSH_USER@$SSH_HOST << 'EOF'
            set -e
            BACKUP_DIR="/opt/flowstate-ai/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            
            # Backup database
            docker exec flowstate-db pg_dump -U flowstate flowstate > "$BACKUP_DIR/database.sql"
            
            # Backup volumes
            docker run --rm -v flowstate_data:/data -v "$BACKUP_DIR":/backup alpine tar czf /backup/volumes.tar.gz /data
            
            echo "✅ Backup created: $BACKUP_DIR"
          EOF

      - name: Deploy to production (Blue-Green)
        id: deploy
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
          SSH_USER: ${{ secrets.PRODUCTION_USER }}
          SSH_PORT: ${{ secrets.PRODUCTION_PORT || '22' }}
          VERSION: ${{ steps.meta.outputs.version }}
        run: |
          ssh -i ~/.ssh/deploy_key -p $SSH_PORT $SSH_USER@$SSH_HOST << EOF
            set -e
            cd /opt/flowstate-ai
            
            # Pull new images
            docker pull ghcr.io/${{ github.repository }}/backend:${VERSION}
            docker pull ghcr.io/${{ github.repository }}/frontend:${VERSION}
            docker pull ghcr.io/${{ github.repository }}/python-worker:${VERSION}
            
            # Start green environment
            docker-compose -f docker/compose.green.yml up -d
            
            # Wait for green environment to be healthy
            echo "Waiting for green environment..."
            sleep 30
            
            # Health check green environment
            if ! curl -f -s http://localhost:8081/health > /dev/null; then
              echo "❌ Green environment health check failed"
              docker-compose -f docker/compose.green.yml down
              exit 1
            fi
            
            # Switch traffic to green (update load balancer)
            echo "Switching traffic to green environment..."
            # Update nginx/load balancer configuration here
            
            # Stop blue environment
            docker-compose -f docker/compose.yml down
            
            # Rename green to blue
            docker-compose -f docker/compose.green.yml down
            docker-compose -f docker/compose.yml up -d
            
            echo "✅ Deployment completed"
          EOF
          
          echo "url=https://flowstate-ai.com" >> $GITHUB_OUTPUT

      - name: Run production health checks
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL || 'https://flowstate-ai.com' }}
        run: |
          echo "Running production health checks..."
          
          # Wait for services
          for i in {1..60}; do
            if curl -f -s "${PRODUCTION_URL}/health" > /dev/null; then
              echo "✅ Backend health check passed"
              break
            fi
            echo "Waiting for backend... ($i/60)"
            sleep 10
          done
          
          # Verify backend health
          HEALTH_STATUS=$(curl -s "${PRODUCTION_URL}/health" | jq -r '.status')
          if [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "❌ Backend health check failed"
            exit 1
          fi
          
          # Verify frontend
          if ! curl -f -s "${PRODUCTION_URL}" > /dev/null; then
            echo "❌ Frontend health check failed"
            exit 1
          fi
          echo "✅ Frontend health check passed"
          
          # Verify database connectivity
          DB_STATUS=$(curl -s "${PRODUCTION_URL}/health/db" | jq -r '.status')
          if [ "$DB_STATUS" != "healthy" ]; then
            echo "❌ Database health check failed"
            exit 1
          fi
          echo "✅ Database health check passed"
          
          echo "✅ All production health checks passed"

      - name: Run production smoke tests
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL || 'https://flowstate-ai.com' }}
        run: |
          echo "Running production smoke tests..."
          
          # Test critical endpoints
          curl -f -s "${PRODUCTION_URL}/api/v1/health" || exit 1
          echo "✅ API health endpoint working"
          
          curl -f -s "${PRODUCTION_URL}/api/v1/auth/status" || exit 1
          echo "✅ Auth endpoint working"
          
          # Test database queries
          curl -f -s "${PRODUCTION_URL}/api/v1/stats" || exit 1
          echo "✅ Database queries working"
          
          echo "✅ Production smoke tests passed"

      - name: Monitor for errors
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL || 'https://flowstate-ai.com' }}
        run: |
          echo "Monitoring for errors (5 minutes)..."
          
          for i in {1..30}; do
            ERROR_COUNT=$(curl -s "${PRODUCTION_URL}/health/errors" | jq -r '.count')
            if [ "$ERROR_COUNT" -gt 10 ]; then
              echo "⚠️ High error count detected: $ERROR_COUNT"
              echo "Consider rollback"
            fi
            sleep 10
          done
          
          echo "✅ Error monitoring completed"

      - name: Create deployment record
        if: always()
        run: |
          echo "## Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ steps.meta.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: ${{ steps.meta.outputs.timestamp }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: production" >> $GITHUB_STEP_SUMMARY
          echo "**URL**: ${{ steps.deploy.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "**Status**: ✅ Deployed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status**: ❌ Deployment failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Rollback on failure
        if: failure()
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
          SSH_USER: ${{ secrets.PRODUCTION_USER }}
          SSH_PORT: ${{ secrets.PRODUCTION_PORT || '22' }}
        run: |
          echo "⚠️ Production deployment failed, initiating rollback..."
          
          ssh -i ~/.ssh/deploy_key -p $SSH_PORT $SSH_USER@$SSH_HOST << 'EOF'
            set -e
            cd /opt/flowstate-ai
            
            # Stop failed green environment
            docker-compose -f docker/compose.green.yml down
            
            # Restore from backup if needed
            LATEST_BACKUP=$(ls -t /opt/flowstate-ai/backups/ | head -1)
            if [ -n "$LATEST_BACKUP" ]; then
              echo "Restoring from backup: $LATEST_BACKUP"
              # Restore database
              docker exec -i flowstate-db psql -U flowstate flowstate < "/opt/flowstate-ai/backups/$LATEST_BACKUP/database.sql"
            fi
            
            # Ensure blue environment is running
            docker-compose -f docker/compose.yml up -d
            
            echo "✅ Rollback completed"
          EOF

  post-deployment:
    name: Post-Deployment Tasks
    needs: deploy-production
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Clear CDN cache
        run: |
          echo "Clearing CDN cache..."
          # Add CDN cache clearing here
          echo "✅ CDN cache cleared"

      - name: Warm up caches
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL || 'https://flowstate-ai.com' }}
        run: |
          echo "Warming up caches..."
          curl -s "${PRODUCTION_URL}" > /dev/null
          curl -s "${PRODUCTION_URL}/api/v1/health" > /dev/null
          echo "✅ Caches warmed up"

      - name: Update status page
        run: |
          echo "Updating status page..."
          # Add status page update here
          echo "✅ Status page updated"

  notify:
    name: Send Deployment Notification
    needs: [deploy-production, post-deployment]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send success notification
        if: needs.deploy-production.result == 'success'
        run: |
          echo "✅ Production deployment successful"
          echo "Version: ${{ needs.deploy-production.outputs.version }}"
          # Add Slack/Discord/Email notification here

      - name: Send failure notification
        if: needs.deploy-production.result == 'failure'
        run: |
          echo "❌ Production deployment failed"
          echo "Version: ${{ needs.deploy-production.outputs.version }}"
          # Add urgent notification here

